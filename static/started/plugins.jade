include ../.layout.jade

doctype html
html(lang=gw.language)
	- var path = [{label:'Getting started',url:'/reference/'},{label:'Middleware',url:'/reference/middleware.jade'}];
	+starting-layout("Getting started Pillars.js - 'make it easy!'",path)

		#title
			h1 Middleware
				em  Comenzando con Pillars.js			

		//- Summary
		section.summary
			h2#summary Sumario
			:marked
				El middleware permite ampliar las funcionalidades del framework. 

				Pillars.js ofrece un middleware **vitaminado** y con mucho más **control**. Las características principales son:
								
				- Un middleware instalado se puede ejecutar de forma **global** *en toda la aplicación*, o sólo en **determinados controladores**.
				- Un middleware se puede activar y desactivar "en caliente".
				- Todos los middleware instaladados en el sistema se ejecutan de forma **secuencial**, por lo que tienen un orden. Este orden se puede modificar.
				- Cuando creamos un middleware le asignamos un identificador, para posteriormente poder trabajar con el. 
				- El framework Pillars.js tiene diez middleware built-in. Puedes consultarlos [aquí](plugins-avanzado.jade#plugins-built-in).
				- Todos los middleware, tanto los built-in como los instalados, están localizados en la denominada **cadena de middleware**, es decir, en **project.plugins**.

		//- Syntax
		section.syntax
			h2#syntax Constructor
			:codesyntax
				middleware = new Middleware( configuration, handler );

			:marked
				+ *configuration*: opcional. Objeto de configuración. En la creación del middleware se pueden configurar los siguientes parámetros. 
					+ [id](#property-id): **String** identificador. Si no se especifica se autogenera.
					+ [active](#property-active): **Boolean**, indica si está activo o no. Por defecto es true.

				+ *handler*: Manejador que ejecutará. El manejador siempre recibe como parámetro el [objeto gangway](gangway.jade) y **next**. Mediante `next();` se indica que ejecute el siguiente middleware.

						
			:highlight(lang='javascript')
				// Creación de un objeto middleware con id 'idMiddleware'

				var myMiddleware = new Middleware({
						id: "idMiddleware"
					},function(gw, next){
						console.log("Hello from the other side, I'm a middleware");
						next();
				});

				project.middleware.add(myMiddleware); // Se añade el objeto al proyecto
		:marked
			Por otro lado, te recomendamos la notación más corta y sin necesidad de declarar variables intermedias: 
		:highlight(lang='javascript')
				project.middleware.add( // Añadimos al proyecto
					new Middleware({    // Creamos el objeto
							id: "idMiddleware"
						},function(gw, next){
							console.log("Hello from the other side, I'm a middleware");
							next();
				}));

		section.manipular-middleware
			h2#flujo-manipular-middleware Manipular Middleware
			:marked
				Recuerda que la propiedad del proyecto `project.middleware` es de tipo *Object Array* por lo que dispones de métodos para capturar estos objetos, añadir, eliminar, etc.
				Para capturar un middleware usa el método `.get()` de la siguiente forma: 

			:highlight(lang='javascript')
				project.middleware.get('BodyReader').tempDirectory = "/temporal";
			:marked
				En este caso hemos capturado el plugin built-in [BodyReader](plugins-avanzado.jade#plugin-bodyreader) y hemos modificado la propiedad *tempDirectory*. De esta forma cambiamos la ruta temporal donde se guardarán los archivos en la aplicación (*petición POST con subida de archivos*).
			:highlight(lang='javascript')
				project.middleware.get('BodyReader').active = false;
				//Desactivamos el middleware BodyReader.
					
		section.aplicarmiddleware
			h2#aplicarmiddleware Middleware y controladores
			:marked
				Como ya hemos comentado, el middleware "instalado" puede ejecutarse en **toda la aplicación**, es decir, aplicarse en **todos los controladores**, o por el contrario aplicarse sólo en **determinados controladores**. En este sentido debemos crear en la configuración del controlador una propiedad, la cual estará disponible en el middleware y por lo tanto podremos consultarla.

				Para ilustrar el funcionamiento del middleware, puedes copiar el código siguiente y ejecutarlo: 

			:highlight(lang='javascript')
				var project = require("pillars");

				project.services.get("http").start();

				// Instancia del controlador con propiedad creada, ésta estará disponible en el middleware
				project.routes.add(new Route({
						id: 'schrodinger-route',
						path:'/schrodinger',
						catExist: true // Esta es la propiedad
					},
					function(gw){
						gw.send("¿Hay Gato o no hay gato? - Mira la consola para averiguarlo");
				}));


				// Instancia de otro controlador. Este cambiará el valor de catExist del otro controlador.
				project.routes.add(new Route({
						path:'/cambia'
					},
					function(gw){
						var targetRoute = project.routes.get("schrodinger-route");  
						targetRoute.catExist = !targetRoute.catExist;
						gw.send("Ahora el valor de catExist es: "+targetRoute.catExist);
				}));

				// Instancia de otro controlador.Sólo envía un texto, pero veremos que para el, nunca hay gato.
				project.routes.add(new Route({
						path:'/paso'
					},
					function(gw){
						gw.send("Yo paso del schrodinger ese.");
				}));


				// Instancia de objeto middleware 
				project.middleware.add(new Middleware({
						id: "schrodinger-midd"
					},function(gw, next){
						if (gw.routing.inheritance.catExist){
							console.log("Hay Gato!!");
						}else{
							console.log("¡¡No hay gato!!");
						}
						next();
				}));
			:marked
				Observa los mensajes en consola mientras visitas las rutas `/cambia`, `/paso` y `/schrodinger`. 
				Verás que en todas las rutas el middleware entra en acción. Ahora bien, dependiendo de si el controlador tiene definida la propiedad `catExist` y a la vez está establecida en `true`, ejecutará una cosa u otra. Todo esto es posible gracias a una sencilla sentencia condicional y que dicha propiedad está contenida en **gangway**.


		section.orden
			h2#Orden Orden de ejecución
			:marked
				Todo el middleware "instalado" en el proyecto se ejecuta de forma secuencial, siguiendo un orden. Este orden está definido en la *cadena de middleware*, que es **project.middleware**.

				Tenemos la posibilidad de re-ordenar esta lista para que se ejecuten en el orden deseado.

			.msg.msg-icon.bg-info Si rompes algo tocando middleware del sistema, ... ¡¡reinstala y listo xD!!)
			:marked
				Veamos un ejemplo. Creamos y añadimos dos plugins. Uno de ellos escribirá por consola: "Hola soy el plugin 1", y el segundo: "Hola soy el plugin 2". Posteriormente le cambiaremos el orden: 
			:highlight(lang='javascript')
				var project = require('pillars');

				project.services.get('http').start();

				project.routes.add(
					new Route(
					    {
					      id:"home",
					      path:"/"
					    },
					    function(gw){
					      gw.html("Hola Mundo!!");
					    }
					)
				);

				project.plugins.add(
					new Plugin(
						{
							id: "idPlugin-1"
						},
						function(gw, next){							
							console.log("Hola soy el plugin 1");
							next();
						}
					)
				);
				project.plugins.add(
					new Plugin(
						{
							id: "idPlugin-2"
						},
						function(gw, next){
							console.log("Hola soy el plugin 2");
							next();
						}
					)
				);
			:marked
				Al ejecutar la aplicación del ejemplo, vemos que primero se ejecuta el plugin "idPlugin-1" y posteriormente el plugin "idPlugin-2". Hay que tener en cuenta que los plugins son bloqueantes, y que no se ejecutará el siguiente plugin hasta que el que está actuando finalice. Una vez que finalicen de ejecutarse todos los plugins, será entonces cuando pase el control al controlador en cuestión (objeto route encargado de manejar la petición).

				![Captura ejemplo Plugins](../img/started/plugins.jpg)

				Para cambiar el orden de ejecución en la cadena de plugins contamos con métodos de ordenación, puedes consultarlos en la [librería ObjectArray](https://github.com/pillarsjs/ObjectArray). En el caso del ejemplo, para hacer que el "idPlugin-2" se ejecute antes que "idPlugin-1", podemos utilizar el método *.moveAfter()*, que mueve el objeto con el identificador especificado como primer parámetro, a la posición siguiente del objeto cuyo identificador especificamos como segundo valor:
			:highlight(lang='javascript')
					project.plugins.moveAfter("idPlugin-1","idPlugin-2");		