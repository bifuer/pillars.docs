include ../.layout.jade

doctype html
html(lang=gw.language)
	- var path = [{label:'Pillars - Make it easy',url:'/reference/'},{label:'Getting Started',url:'/reference/index.jade'}];
	+reference-layout("Pillars.js Reference - Getting Started - 'Make it easy!'",path)

		#title
			h1 Getting Started
				em  Pillars.js Reference
			

		//- Summary
		section.summary
			h2#summary Welcome
			:marked
				Welcome to **Pillars.js**, a modular framework for Web Development in Node.js.

				With a simple and modular approach, lets you start in Node.js with a soft learning curve, if you´re an advanced JS/Node developer get JS workbench organized and effective.

			:highlight(lang='javascript')
				var project = require('pillars');

				project.services.get('http').start();

				project.routes.add(new Route({
						id: 'myRoute',
						path: '/mypath',
						method: ['GET','POST']
					},function(gw){
						gw.html("Hello World!!");
					});


		section.environment
			h2#environment Installing Node.js
			:marked
				To start using Pillarsjs need Node.js installed. [Install from here.](https://nodejs.org/) 

				Make a new directory and add two basic files: *package.json* (application descriptor) and *app.js* (the main projec).

				*package.json* file allows you to set many parameters. Initially it´s enougth describe that you´ll use Pillars.js: 

			:highlight(lang='javascript')
				{
				  "dependencies": {
				    "pillars": "*"
				  }
				}

			:marked
				> You can find more info about *package.json* on [npm](https://www.npmjs.org/doc/files/package.json.html).

				Now, goes to console and execute in  directory `npm install` command. This action will create a *node_modules* directory, which the units described are placed.

				On *app.js* write a basic example like this:

			:highlight(lang='javascript')
					var project = require('pillars');

					project.services.get('http').configure({port:3000}).start();

					project.routes.add(new Route({
					  id: 'Home',
					  path: '/',
					  method: ['get','post']
					},function(gw){
					  gw.html("Hello World!!");
					});

			:marked
				To run application write on console `node app.js`. 
				> To stop application use `ctrl+c`.

		section.framework
			h2#framework The framework
			:marked
				Main concepts in Pillars.js are:
				- **Environment/project**: main element to setup and management the project. Allow add route controller (*route object*) and Plugins among others. Get *project* with require sentence: `var project = require('pillars');`
				- **Route**: route controller, a class to create a *handler* and their *configuration*. Receives a *gangway object* by parameter and are nestable. 
				- **Gangway**: an object with propierties and methods related with the request management, is a 'clean' wrap for Node *request* and *response*.
				- **Plugin**: allows create controllers for the general environment, can modify *Gangway* and *Route* performance and access their propierties.

				Pillars.js include aditional libraries developed in parallel: 
				- **Textualization**: extend i18n support for JS.
				- **Scheduled**: Manager tasks scheduled to cron style.
				- **Crier**: Management system logs.
				- **Procedure**: Utility to provide writing sets of asynchronous sentences. 
				- **Templated**: Manager for template engines with compilation cache.
				- **ObjectArray**: Intensively used in PIllars.js to organize/manage object sets.
				- **String.format**: Method for *String class*, allows format text templates.
				- **Date.format**: Method for *Date class*, allows easily format dates.
				- **JSON.decycled**: Set of methods for *JSON class* that solve circular references provblems among others.
				- **JSON.crypt**: encryption/decryption utility of JS objects.


		section.project
			h2#project Project (Environment)
			:marked
				When `var project = require('pillars')` is used, get an environment reference, or what is the same, the focus of work for the project. Allows set up general system performance and gives central access to methods: route/controller structure, runing Plugins, available services and other propierties of the system.

				Invoking for the first time Pillars.js library are globally setted more important classes as *Route* and *Plugin*, that you can use inmediatly.

				Pillars.js use *services* as a shared entity in throughout environment, to which can access to interact with it other modules that are included in project. *services* offer a cross structure for all the project code.

				Pillars.js has a HTTPService preset, so you don´t need create one. (Unless you need multiple HTTP/S services).

				Get *services* in `project.services` propiertie, this is an [ObjectArray](https://github.com/bifuer/ObjectArray) in which you can get any service of the *services* in your project. Below a simple server set up:

			:highlight(lang='javascript')
				var project = require('pillars');

				project.services.get('http').configure({
				  port:3000,
				  timeout: 30*1000,
				  hostname: 'sub.dom.ext'
				}).start();

			:marked
				Environment vars setting is available in `project.config`, you can set up propierties at once using `project.configure({...})` method:

			:highlight(lang='javascript')
				var project = require('pillars').configure({
					  debug: true, // false by default
					  renderReload: true, // stop or start templates cache
					  cors: false, // Determines permitted souces for CORS
					  cacheMaxSize : 250*1024*1024, // Set the maximum size of cache memory dedicated to files served
					  fileMaxAge : 7*24*60*60, // Default expiration of files served
					});

			:marked
				Finally we have methods that allows to manage *routes* and *plugins* in application. All controllers and all plugins are located in `project.routes` and in `project.plugins` respectively:
				- `project.routes.add(new Route())`: add a new controller to system. With `.remove()` you can delete controllers and with `.get()` you can get it for modify those were added. A *route* object has `.routes` propiertie in which you can add other controllers, allowing create tree structures (nesetable). Controller nested inherit configurations of their predecessors.
				- `project.plugins.add(new Plugin())`: add a new plugin to system. With `.remove()` you can delete plugins and with `.get()` you can get it for modify those were added. Pillars.js include by default some plugins that perform essential functions for the system, among them the most important is the *router.js*, plugin that manages the entire routing system.

		section.route
			h2#route Route Class
			:marked
				Class that associates a *handler* with a particular *configuration*. A *route object* consist in a *handler* and a *propierties set* that allows to define when and how execute this *handler*. *route object* basic declaration is leaving defaults options, it´s to say, without this *propierties set*:

			:highlight(lang='javascript')
				var myRoute = new Route(function(gw){
					  gw.send('¡Hola Mundo!');
					});

			:marked
				Althougth in most cases we need to set *object route* with this *propierties set* as follows:

			:highlight(lang='javascript')
				var myRoute = new Route({ // Propierties set
					  id:'Status',
					  path:'admin/status',
					  method:['get','post']
					},function(gw){ // Handler
					  gw.html('¡Hola Mundo!');
					});

			:marked
				Route Class set by default:
				- `.id`: an unique identifier is generated.
				- `.path`: '/'.
				- `.method`: all methods.


				*route objects* (controllers) can have others *route objects* as children, these works like sub-controllers, allowing to organize the tree controller in an organically way. This allows work with inheritance propierties and have an organized control over controller groups.

			:highlight(lang='javascript')
				var adminArea = new Route({
				  id: 'Administration',
				  path: '/admin'
				},function(gw){
				  gw.html('Admin area');
				});

				adminArea.routes.add(new Route({
				    id: 'Status',
				    path: '/status'
				  },function(gw){
				    gw.html('Admin area: Show status');
				}))

			:marked
				*route object* with `Status` id, respond to '/admin/status' path. If *route* with 'Administration' id is desactivated, this will no longer available neither all his descendants.

				`.active` propierty of *route* allows desactivate a *route object* along with their descendants.

		section.gangway
			h2#gangway Gangway (gw)
			:marked
				If you has worked with Node sure you know about `request` and `response`. In Pillars.js this objects are *Gangway* propierties. 


					/*
	

					### Gangway (gw)

					Es la solicitud HTTP, si ya has trabajado con Node.js estarás acostumbrado a los objetos `request` y `response`. En Pillars.js estos objetos son propiedades de Gangway, un objeto Gangway consiste en la solicitud del cliente completamente parseada y organizada para su uso. Con cada solicitud al servidor HTTP se crea un objeto Gangway que es recibido por el Route/manejador correspondiente. Algunas de las propiedades y métodos de Gangway:

					 - **`.cookie`**: Devuelve un objeto con el contenido de la *cookie*, si existiese.
					 - **`.ua`**: Un objeto con información sobre el agente de usuario, `.mobile` nos indica (*booleano*) si el cliente es un dispositivo móvil y el resto de propiedades nos aporta información sobre el sistema operativo y el navegador (os,engine,browser).
					 - **`.ip`**: La dirección IP del cliente.
					 - **`.accepts`**: Cabeceras accept ya resueltas y organizadas por prioridad.
					 - **`.host`**: El nombre de host o dirección IP que se ha utilizado al realizar la petición.
					 - **`.method`**: El método utilizado por la petición (*GET,POST,PUT,DELETE,HEAD*).
					 - **`.path`**: Ruta que se ha solicitado, exclusivamente el valor de la ruta sin la parte *host* ni *query*, este valor puede verse modificado internamente si por alguna razón una ruta es redirigida a otro punto del entorno, para conocer el *path* original tenemos la propiedad **`.originalPath`**.
					 - **`.query`**: Un objeto con el contenido del *query* de la petición.
					 - **`.params`**: Un objeto con todos los parámetros recibidos en la petición, ya sea por *GET* o *POST*. Los valores *POST* prevalecerán sobre los de *GET* en caso de ser idénticos.
					 - **`.files`**: Un objeto que contiene únicamente los archivos, si existiesen, que han sido enviados en la petición. En `.params` también podremos encontrar dichos archivos junto con el resto de parámetros que fueron enviados.
					 - **`.session`**: Un objeto que mantendrá sus propiedades entre distintas peticiones del mismo cliente.
					 - **`.referer`**: Si la solicitud se ha realizado por medio de un *link*, este valor nos indica la dirección que nos ha referenciado.

					> Puedes encontrar una descripción más amplia y el resto de propiedades
					> en la referencia.

					 - **`.setHeader(name, value)`**: Añade un encabezado a la respuesta. `getHeader(name)` y `removeHeader(name)`, nos permite leer un valor de encabezado ya existente o eliminarlo, como este se incluyen alias de los métodos propios de `response`.
					 - **`.setCookie(name, value, config)`**: Prepara una cookie para adjuntar a la respuesta, será encriptada por medio de JSON.crypt.
					 - **`.send(data)`**: Envía el contenido especificado al cliente y termina la petición, si *data* es un *objeto* se convertirá en *JSON* y la respuesta se enviará como *'aplication/json',* si data es un *string* será enviado como *'text/html'*. Existen, además, métodos explícitos para cada tipo de respuesta `.html()`, `.json`, `.text`.
					 - **`.file(path, clientname, download)`**: Envía un archivo al cliente, mediante `clientname` podremos especificar un nombre que será utilizado en el diálogo de guardado y con `download=true` podremos forzar la descarga del mismo. Por defecto el nombre es el que corresponda en la ruta y forzar descarga es *false*. Adicionalmente, el archivo será **comprimido** antes de su envío y quedará cacheado en memoria para sucesivas peticiones, este método es compatible la negociación **byte-serve** de HTTP por lo que si la descarga es interrumpida podrá continuar en una siguiente solicitud desde el último byte recibido, siendo también utilizado por clientes de video para descarga selectiva. Este método también tiene *gestión de caché automática*, por lo que si el cliente ya tiene el archivo no volverá a ser enviado y se responderá con un código *304*.
					 - **`.cacheck(hash)`**: Nos permite gestionar la caché del cliente, debemos pasar valor identificativo (hash, checksum, timestamp) para comprobar si el contenido solicitado es idéntico al que ya tiene el cliente, este método responderá con *false* si el cliente no tiene cacheado el contenido y *true* junto con un *304* automáticamente si el cliente ya dispone del contenido. La forma ideal de utilizar este método es como condición en una sentencia *if*, de la forma `if(!cacheck(hash)){}`.
					 - **`.authenticate(msg)`**: Envía un mensaje de *autenticación HTTP básica* con el código *401*. Podremos comprobar las credenciales del usuario en la propiedad `.auth` de Gangway, este objeto contendrá el nombre de usuario y contraseña indicados por el cliente en las propiedades `.user` y `.pass`.
					 - **`.redirect(location)`**: Redirige la solicitud a otra dirección mediante un código *301*.
					 - **`.render(template, locals)`**: Definiendo la ruta a un template y la variables de entorno con las que debe trabajar enviaremos al cliente el resultado como HTML. Pillars.js permite añadir motores de plantillas mediante `templated.addEngine(ext,compiler)`.
					 - **`.error(code, data)`**: Mediante este método podemos mostrar mensajes de *error* manualmente, nos permite especificar un *status-code (404, 500...)* y un objeto *Error* si fuese necesario, el objeto *Error* no se mostrará al cliente si la variable de entorno `debug` es *false*.

					## Plugin

					Los plugins te permiten crear controladores globales que podrán acceder a las propiedades de Route, ampliar las funciones de Gangway o modificar el comportamiento general del framework.

					Son la parte central de la gestión de solicitudes en Pillars.js. Cuando se recibe una solicitud HTTP se instancia un nuevo objeto Gangway, éste es enviado a una cadena de plugins organizados que irán pasando el control de dicho Gangway al siguiente Plugin.

					La construcción de un plugin es muy similar a la de un Route, es necesario especificar unas propiedades y un manejador. Los plugins solo tienen dos propiedades, `.id` y `.active`:

					```javascript
					myPlugin = new Plugin({
					  id: 'paramsLog'
					}, function(gw,next){
					  console.log(gw.params);
					  next();
					});
					project.plugins.add(myPlugin);
					```

					Este plugin de ejemplo envía a la consola los parámetros de cualquier solicitud recibida y pasa el control al siguiente plugin. Plugin a diferencia de Route recibe dos parámetros en el manejador 'gw' y 'next', next es un método que nos permite pasar el control al siguiente Plugin.

					Uno de los Plugins integrados, y más importante, es 'Router' que decide qué objeto Route es el encargado de atender una solicitud concreta, pasando el control al manejador de dicho Route cuando finaliza la cadena de Plugins.

					Cuando el control llega al Plugin 'Router', éste busca el Route adecuado para la solicitud, en caso de encontrar uno guarda la referencia en la propiedad `routing` de Gangway y continua la ejecución de la cadena de plugins. En caso contrario reponde con un 404 y detiene la cadena de Plugins.

					Desde cualquier Plugin con prioridad posterior a 'Router' se tendrá acceso a la propiedad `gw.routing` que tiene el siguiente formato:
					- `gw.routing.routes`: Cadena de Routes que se ha seguido si estos han sido anidados, en orden de descendencia.
					- `gw.routing.handlers`: Manejador o manejadores del Route que responderá a la ruta. Serán llamados al finalizar la cadena de Plugins.
					- `gw.routing.options`: Objeto con las propiedades del Route que atenderá la solicitud, propias y heredadas de otros Routes superiores.
					- `gw.routing.check(prop, preset)`: Utilidad para comprobar propiedades del Route pudiendo recibir el valor `preset` en caso de no estar definida.

					La propiedad `gw.routing` nos permite crear Plugins que sólo se ejecutarán ante configuraciones concretas Route, por ejemplo un Plugin que realize log como el ejemplo anterior pero sólo para objetos Route que tengan la propiedad 'log=true':

					```javascript
					myPlugin = new Plugin({
					  id: 'logPlugin'
					},function(gw,next){
					  var log = gw.routing.check('log');
					  if(log===true){
					    console.log(gw.path,gw.params);
					  }
					  next();
					});
					project.plugins.add(myPlugin);
					```

					Mediante Plugins podemos actuar tanto antes como después de pasar por el Router, pudiendo por ejemplo modificar la ruta o métodos antes del Router o comprobar propiedades del objeto Route cuando éste ya ha sido seleccionado. Cada Plugin puede modificar o extender las propiedades y métodos de Gangway para nuestro manejador, por ejemplo el Plugin 'sessions' nos ofrece la propiedad `gw.session` en la cual se encarga de insertar los valores almacenados en la sesión y guardar los cambios una vez finalizada la solicitud.

					Los Plugins ofrecen una forma de añadir funcionalidades a Pillars.js o modificar su comportamiento general, esto es útil para crear Plugins genéricos que añadan funciones a cualquier proyecto o para realizar tareas comunes entre diferentes manejadores pudiendo disparar el Plugin sólo ante ciertas propiedades/configuraciones de Route.*/
