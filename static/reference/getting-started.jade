include ../.layout.jade

doctype html
html(lang=gw.language)
	- var path = [{label:'Pillars - Make it easy',url:'/reference/'},{label:'Getting Started',url:'/reference/index.jade'}];
	+reference-layout("Pillars.js Reference - Getting Started - 'Make it easy!'",path)

		#title
			h1 Getting Started
				em  Pillars.js Reference
			

		//- Summary
		section.summary
			h2#summary Welcome
			:marked
				Welcome to **Pillars.js**, a modular framework for Web Development in Node.js.

				With a simple and modular approach, lets you start in Node.js with a soft learning curve, and if you´re an advanced JS/Node developer get JS workbench organized and effective.

			:highlight(lang='javascript')
				var project = require('pillars');

				project.services.get('http').start();

				project.routes.add(new Route({
						id: 'myRoute',
						path: '/mypath',
						method: ['GET','POST']
					},function(gw){
						gw.html("Hello World!!");
					});


		section.environment
			h2#environment Installing Node.js
			:marked
				To start using Pillarsjs need Node.js installed. [Install from here.](https://nodejs.org/) 

				Make a new directory and add two basic files: *package.json* (application descriptor) and *app.js* (the main projec).

				*package.json* file allows to set many parameters. Initially you describe that you use Pillars.js like dependency, is enough:

			:highlight(lang='javascript')
				{
				  "dependencies": {
				    "pillars": "*"
				  }
				}

			:marked
				> You can find more info about *package.json* file on [npm](https://www.npmjs.org/doc/files/package.json.html).

				Now in console execute (in your project directory) `npm install` command. This action will create a *node_modules* directory, which the units described are placed.

				On *app.js* write a basic example like this:

			:highlight(lang='javascript')
					var project = require('pillars');

					project.services.get('http').configure({port:3000}).start();

					project.routes.add(new Route({
					  id: 'Home',
					  path: '/',
					  method: ['get','post']
					},function(gw){
					  gw.html("Hello World!!");
					});

			:marked
				To run application write in console `node app.js`. 
				> To stop application use `ctrl+c`.

		section.framework
			h2#framework The framework
			:marked
				Main concepts in Pillars.js are:
				- **Environment/project**: main element to setup and management the project. Allows add route controller (*route object*) and Plugins (*plugin object*) among others. Get *project* with require sentence: `var project = require('pillars');`
				- **Route**: route controller, a class to create a *handler* with a *configuration*. Receives a *gangway object* by parameter and are nestable. 
				- **Gangway**: an object with properties and methods related with the request management, is a 'clean' wrap for Node *request* and *response*.
				- **Plugin**: allows create controllers for the general environment, can modify *Gangway* and *Route* performance and access to their properties.

				Pillars.js include aditional libraries developed in parallel: 
				- **Textualization**: extend i18n support for JS.
				- **Scheduled**: Manager tasks scheduled with cron style.
				- **Crier**: Management 'system logs'.
				- **Procedure**: Utility to provide writing of asynchronous sentences sets.
				- **Templated**: Manager for template engines with compilation cache.
				- **ObjectArray**: Intensively used in Pillars.js to organize/manage object sets.
				- **String.format**: Method for *String class*, allows format text templates.
				- **Date.format**: Method for *Date class*, allows easily format dates.
				- **JSON.decycled**: Set of methods for *JSON class* that solve circular references provblems among others.
				- **JSON.crypt**: encryption/decryption utility of JS objects.


		section.project
			h2#project Project (Environment)
			:marked
				When `var project = require('pillars')` is used, get an environment reference, or what is the same, the focus of work for the project. Allows set up general system performance and gives you central access to: *controllers structure*, *running Plugins*, *available services* and other system properties.

				When you invoke Pillars.js library at the first time, more important classes as *Route* and *Plugin* are globally set, so you can use it immediately.

				Pillars.js use *services* as a shared entity throughout environment, to which can access to interact with it other modules that are included in project. *services* offer a cross structure for all the project code.

				Pillars.js has a HTTPService preset, so you don´t need create one. (Unless you need multiple HTTP/S services).

				Get *services* in `project.services` property, this is an [ObjectArray](https://github.com/bifuer/ObjectArray) in which you can get any service of the *services* in your project. Below a simple server set up:

			:highlight(lang='javascript')
				var project = require('pillars');

				project.services.get('http').configure({
				  port:3000,
				  timeout: 30*1000,
				  hostname: 'sub.dom.ext'
				}).start();

			:marked
				Environment vars setting is available in `project.config`, you can set up properties at once using `project.configure({...})` method:

			:highlight(lang='javascript')
				var project = require('pillars').configure({
					  debug: true, // false by default
					  renderReload: true, // stop or start templates cache
					  cors: false, // Determines permitted souces for CORS
					  cacheMaxSize : 250*1024*1024, // Set the maximum size of cache memory dedicated to files served
					  fileMaxAge : 7*24*60*60, // Default expiration of files served
					});

			:marked
				Finally we have methods that allows to manage *routes* and *plugins* in application. All *controllers* and all *plugins* are located in `project.routes` and in `project.plugins` respectively:
				- `project.routes.add(new Route())`: add a new controller to system. With `.remove()` you can delete controllers and with `.get()` you can get it for modify those were added. A *route* object has `.routes` property in which you can add other controllers, allowing create tree structures (nesetable). Controller nested inherit configurations of their predecessors.
				- `project.plugins.add(new Plugin())`: add a new plugin to system. With `.remove()` you can delete plugins and with `.get()` you can get it for modify those were added. Pillars.js include by default some plugins that perform essential functions for the system, among them the most important is the *router.js*, plugin that manages the entire routing system.

		section.route
			h2#route Route Class
			:marked
				Class that associates a *handler* with a particular *configuration*. A *route object* consist in a *handler* and a *property set* that allows to define when and how execute this *handler*. *route object* basic declaration is leaving defaults options, it´s to say, without this *property set*:

			:highlight(lang='javascript')
				var myRoute = new Route(function(gw){
					  gw.send('¡Hola Mundo!');
					});

			:marked
				Althougth in most cases we need to set *object route* with this *property set* as follows:

			:highlight(lang='javascript')
				var myRoute = new Route({ // property set
					  id:'Status',
					  path:'admin/status',
					  method:['get','post']
					},function(gw){ // Handler
					  gw.html('¡Hola Mundo!');
					});

			:marked
				Route Class set by default:
				- `.id`: an unique identifier is generated.
				- `.path`: '/'.
				- `.method`: all methods.


				*route objects* (controllers) can have others *route objects* as children, these works like sub-controllers, allowing to organize the tree controller in an organically way. This allows work with inheritance properties and have an organized control over controller groups.

			:highlight(lang='javascript')
				var adminArea = new Route({
				  id: 'Administration',
				  path: '/admin'
				},function(gw){
				  gw.html('Admin area');
				});

				adminArea.routes.add(new Route({
				    id: 'Status',
				    path: '/status'
				  },function(gw){
				    gw.html('Admin area: Show status');
				}))

			:marked
				*route object* with `Status` id, respond to '/admin/status' path. If *route* with 'Administration' id is desactivated, this will no longer available neither all his descendants.

				`.active` property of *route* allows deactivate a *route object* along with their descendants.

		section.gangway
			h2#gangway Gangway (gw)
			:marked
				If you has worked with Node sure you know about `request` and `response`. A *gangway object* is the request completely parsed and organizad for use. With each HTTP request to the server, a *gangway object* is generated which is received by a *controller*.
				- **`.cookie`**: return an object with *cookie* contents, if any.
				- **`.ua`**: and object with information about user agent. `.mobile` indicaated (*boolean*) if the client is a mobile device and other properties give information about operating system and browser (os, engine, browser).
				- **`.ip`**: IP address of the request.
				- **`.accepts`**: Accept headers already resolved and organized by priority.
				- **`.host`**: the hostname or IP address to which the request is made.
				- **`.method`**: method used by request. (*GET,POST,PUT,DELETE,HEAD*).

				- **`.path`**: path was requested, only the path value without the part of *host* or *query*. this value can be changed internally if for some reason a *controller* redirect this request. To know original path use: `.originalPath` property.
				- **`.query`**: an object with *query* content of the request.
				- **`.params`**: an object with all parameters received on the request, either by *GET* or *POST*. *POST* values prevail over *GET* values if them are identical.
				- **`.files`**: contains only files, if any, that have been sent in the request. In `.params` can also find those files along with other parameters that were sent.
				- **`.session`**: an object that will maintain its properties between different requests from the same client.
				- **`.referer`**: if the request was made by a *link*, this value indicates the URL from where reference is made.

				> You can find a more extend description and other properties in reference.


				- **`.setHeader(name, value)`**: add a header to request.  `getHeader(name)` and `removeHeader(name)` allows read a header value if exists, or delete it. As these aliases, other methods *response* original are included. 
				- **`.setCookie(name, value, config)`**: Prepare a cookie to attach to response, it will be encrypted through JSON.crypt.
				- **`.send(data)`**: send specified content to the client and finish petition. If *data* is an *object* will turn into *JSON* and *request* will be sent as *application/json*, if *data* is a *string*, will be sent as *text/html*. There are also explicit methods for each type of answer like: `.html()`, `.json`, `.text`.

				- **`.file(path, clientname, download)`**: send a file to the client, `clientname` specify a name to be used in the save dialog and `download=true` to force the download. By default filename is the original name, and download is *false*. Additionally, file is **compressed** before sent and is cached in memory for successive requests. This method is compatible with HTTP **byte-serve**, so if download is interrupted may continue in a next request from the last byte received, also it is used by video clients to download the video portion requested. This  method also has **automatic cache management**, so if client already has the file, it will not be sent and server responds a *304* code.


				
					/*

					 - **`.cacheck(hash)`**: Nos permite gestionar la caché del cliente, debemos pasar valor identificativo (hash, checksum, timestamp) para comprobar si el contenido solicitado es idéntico al que ya tiene el cliente, este método responderá con *false* si el cliente no tiene cacheado el contenido y *true* junto con un *304* automáticamente si el cliente ya dispone del contenido. La forma ideal de utilizar este método es como condición en una sentencia *if*, de la forma `if(!cacheck(hash)){}`.
					 - **`.authenticate(msg)`**: Envía un mensaje de *autenticación HTTP básica* con el código *401*. Podremos comprobar las credenciales del usuario en la propiedad `.auth` de Gangway, este objeto contendrá el nombre de usuario y contraseña indicados por el cliente en las propiedades `.user` y `.pass`.
					 - **`.redirect(location)`**: Redirige la solicitud a otra dirección mediante un código *301*.
					 - **`.render(template, locals)`**: Definiendo la ruta a un template y la variables de entorno con las que debe trabajar enviaremos al cliente el resultado como HTML. Pillars.js permite añadir motores de plantillas mediante `templated.addEngine(ext,compiler)`.
					 - **`.error(code, data)`**: Mediante este método podemos mostrar mensajes de *error* manualmente, nos permite especificar un *status-code (404, 500...)* y un objeto *Error* si fuese necesario, el objeto *Error* no se mostrará al cliente si la variable de entorno `debug` es *false*.

					## Plugin

					Los plugins te permiten crear controladores globales que podrán acceder a las propiedades de Route, ampliar las funciones de Gangway o modificar el comportamiento general del framework.

					Son la parte central de la gestión de solicitudes en Pillars.js. Cuando se recibe una solicitud HTTP se instancia un nuevo objeto Gangway, éste es enviado a una cadena de plugins organizados que irán pasando el control de dicho Gangway al siguiente Plugin.

					La construcción de un plugin es muy similar a la de un Route, es necesario especificar unas propiedades y un manejador. Los plugins solo tienen dos propiedades, `.id` y `.active`:

					```javascript
					myPlugin = new Plugin({
					  id: 'paramsLog'
					}, function(gw,next){
					  console.log(gw.params);
					  next();
					});
					project.plugins.add(myPlugin);
					```

					Este plugin de ejemplo envía a la consola los parámetros de cualquier solicitud recibida y pasa el control al siguiente plugin. Plugin a diferencia de Route recibe dos parámetros en el manejador 'gw' y 'next', next es un método que nos permite pasar el control al siguiente Plugin.

					Uno de los Plugins integrados, y más importante, es 'Router' que decide qué objeto Route es el encargado de atender una solicitud concreta, pasando el control al manejador de dicho Route cuando finaliza la cadena de Plugins.

					Cuando el control llega al Plugin 'Router', éste busca el Route adecuado para la solicitud, en caso de encontrar uno guarda la referencia en la propiedad `routing` de Gangway y continua la ejecución de la cadena de plugins. En caso contrario reponde con un 404 y detiene la cadena de Plugins.

					Desde cualquier Plugin con prioridad posterior a 'Router' se tendrá acceso a la propiedad `gw.routing` que tiene el siguiente formato:
					- `gw.routing.routes`: Cadena de Routes que se ha seguido si estos han sido anidados, en orden de descendencia.
					- `gw.routing.handlers`: Manejador o manejadores del Route que responderá a la ruta. Serán llamados al finalizar la cadena de Plugins.
					- `gw.routing.options`: Objeto con las propiedades del Route que atenderá la solicitud, propias y heredadas de otros Routes superiores.
					- `gw.routing.check(prop, preset)`: Utilidad para comprobar propiedades del Route pudiendo recibir el valor `preset` en caso de no estar definida.

					La propiedad `gw.routing` nos permite crear Plugins que sólo se ejecutarán ante configuraciones concretas Route, por ejemplo un Plugin que realize log como el ejemplo anterior pero sólo para objetos Route que tengan la propiedad 'log=true':

					```javascript
					myPlugin = new Plugin({
					  id: 'logPlugin'
					},function(gw,next){
					  var log = gw.routing.check('log');
					  if(log===true){
					    console.log(gw.path,gw.params);
					  }
					  next();
					});
					project.plugins.add(myPlugin);
					```

					Mediante Plugins podemos actuar tanto antes como después de pasar por el Router, pudiendo por ejemplo modificar la ruta o métodos antes del Router o comprobar propiedades del objeto Route cuando éste ya ha sido seleccionado. Cada Plugin puede modificar o extender las propiedades y métodos de Gangway para nuestro manejador, por ejemplo el Plugin 'sessions' nos ofrece la propiedad `gw.session` en la cual se encarga de insertar los valores almacenados en la sesión y guardar los cambios una vez finalizada la solicitud.

					Los Plugins ofrecen una forma de añadir funcionalidades a Pillars.js o modificar su comportamiento general, esto es útil para crear Plugins genéricos que añadan funciones a cualquier proyecto o para realizar tareas comunes entre diferentes manejadores pudiendo disparar el Plugin sólo ante ciertas propiedades/configuraciones de Route.*/
