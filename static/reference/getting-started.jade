include ../.layout.jade

doctype html
html(lang=gw.language)
	- var path = [{label:'Pillars - Make it easy',url:'/reference/'},{label:'Getting Started',url:'/reference/index.jade'}];
	+reference-layout("Pillars.js Reference - Getting Started - 'Make it easy!'",path)

		#title
			h1 Getting Started
				em  Pillars.js Reference
			

		//- Summary
		section.summary
			h2#summary Welcome
			:marked
				Welcome to **Pillars.js**, a modular and scalable framework for Web Development in Node.js.

				Under a simple and modular approach, allows you started development in Node.js with a gentle learning curve, if you are an advanced developer will get JS workbench organized and effective.

			:highlight(lang='javascript')
				var project = require('pillars');

				project.services.get('http').start();

				project.routes.add(new Route({
						id: 'myRoute',
						path: '/mypath',
						method: ['GET','POST']
					},function(gw){
						gw.html("Hello World!!");
					});


		section.environment
			h2#environment Installing Node.js
			:marked
				To start using Pillarsjs need Node.js installed. [Install from here.](https://nodejs.org/) 

				Make a new directory and add two basic files: *package.json* (application descriptor) and *app.js* (the main projec).

				*package.json* file allows you to set many parameters. Initially it´s enougth describe that you´ll use Pillars.js: 

			:highlight(lang='javascript')
				{
				  "dependencies": {
				    "pillars": "*"
				  }
				}

			:marked
				> You can find more info about *package.json* on [npm](https://www.npmjs.org/doc/files/package.json.html).

				Now, goes to console and execute in  directory `npm install` command. This action will create a *node_modules* directory, which the units describeb are placed.

				On *app.js* write a basic example like this:

			:highlight(lang='javascript')
					var project = require('pillars');

					project.services.get('http').configure({port:3000}).start();

					project.routes.add(new Route({
					  id: 'Home',
					  path: '/',
					  method: ['get','post']
					},function(gw){
					  gw.html("Hello World!!");
					});

			:marked
				To run application write on console `node app.js`. 
				> To stop application use `ctrl+c`.

		section.framework
			h2#framework The framework
			:marked
				Main concepts in Pillars.js are:
				- **Environment/project**: mail element to setup and management the project. Allow add route controller (*route object*) and Plugins among others. Get *project* with require sentence: `var project = require('pillars');`
				- **Route**: route controller, a class to create a *handler* and their *configuration*. Receives a *gangway object* by parameter and are nestable. 
				- **Gangway**: 
				- **Plugin**:


					/*

					## El framework

					Los conceptos principales en los que se basa Pillars.js son:
					- **Environment/project**: Punto central de configuración y gestión de nuestro proyecto, permite añadir controladores de ruta (Route) y Plugins entre otras funciones, se obtiene al hacer el require de 'pillars'.
					- **Route**: Controlador de ruta, clase con la que podremos crear un manejador/controlador y su configuración. Recibe un objeto Gangway como parámetro y son anidables.
					- **Gangway**: Un objeto con todas las propiedades y métodos relacionados con la gestión de una solicitud, es una envoltura 'limpia' para los objetos 'request' y 'response' propios de Node.js.
					- **Plugin**: Clase que permite crear controladores para el entorno general, pueden modificar el funcionamiento de Gangway y Route, y acceder a sus propiedades.

					Pillars.js incluye una serie de librerías adicionales desarrolladas de forma paralela al framework:
					- **Textualization**: Ofrece soporte i18n para JS.
					- **Scheduled**: Gestor de tareas programadas al estilo cron.
					- **Crier**: Sistema de gestión de logs.
					- **Procedure**: Utilidad para facilitar la escritura de conjuntos de sentencias asíncronas.
					- **Templated**: Gestor de motores de plantillas con gestión de cache de las compilaciones.
					- **ObjectArray**: Utilizado intensivamente en Pillars.js para organizar/gestionar conjuntos de objetos.
					- **String.format**: Método para la clase String que permite formatear plantillas de texto.
					- **Date.format**: Método para la clase Date que permite formatear fechas de forma sencilla.
					- **JSON.decycled**: Conjunto de métodos para la clase JSON que solucionan los problemas de referencias circulares entre otros.
					- **JSON.crypt**: Utilidad de encriptado/desencriptado de objetos JS.

					### Proyecto (Environment)

					Al utilizar `var project = require('pillars')` obtenemos un referencia al entorno, o lo que es lo mismo, el punto central de trabajo para nuestro proyecto. Nos permite configurar el funcionamiento general del sistema y nos da acceso centralizado a todos sus elementos: estructura de rutas/controladores, Plugins funcionando, Servicios disponibles y otras propiedades del sistema.

					Al invocar por primera vez la librería pillars se establecen de forma global las clases más importantes como Route y Plugin que podrás usar inmediatamente.

					Pillars.js utiliza servicios para cualquier elemento que sea compartido por todo el entorno, como pueden ser, conexiones a bdd, servicio HTTP o HTTPS etc. Por defecto Pillars.js tiene disponible un solo servicio preconfigurado de tipo HttpService, por lo que no necesitaremos crear uno a menos que necesitemos varios servicios HTTP/S.

					Accedemos a los **servicios** por medio de la propiedad `project.services`, un [ObjectArray](https://github.com/bifuer/ObjectArray) en el que podremos localizar cualquiera de los servicios disponibles en el sistema. En el siguiente código puedes ver una configuración sencilla del servidor por defecto.

					```javascript
					var project = require('pillars');

					project.services.get('http').configure({
					  port:3000,
					  timeout: 30*1000,
					  hostname: 'sub.dom.ext'
					}).start();

					```

					La configuración de **variables de entorno** está disponible en `project.config`, podremos configurar varias propiedades a la vez mediante el método `project.configure({...})`, en el ejemplo vemos algunas de las propiedades disponibles.

					```javascript
					var project = require('pillars').configure({
					  debug: true, // Por defecto false
					  renderReload: true, // Detiene el uso de cache de templates
					  cors: false, // determina los origines permitidos para CORS
					  cacheMaxSize : 250*1024*1024, // establece el tamaño máximo de la cache en memoria dedicada a archivos servidos
					  fileMaxAge : 7*24*60*60, // Caducidad por defecto de los archivos servidos
					});
					```

					Por último tenemos los métodos que nos permiten administrar las **rutas** y **plugins** de nuestra aplicación, todas la rutas/controladores de nuestro proyecto se encuentran en el ObjectArray `project.routes` y los Plugins en `project.plugins`:

					- `project.routes.add(new Route())`: Añade una nueva ruta/controlador al sistema. Por medio de `remove()` y `get()` podremos eliminar y modificar respectivamente rutas ya insertadas. Cada objeto Route a su vez contiene una propiedad `.routes` en la que podremos añadir sub rutas, pudiendo crear un árbol de rutas dependientes unas de otras, las rutas anidadas heredan las configuraciones de sus antecesores.

					- `project.plugins.add(new Plugin())`: Añade un nuevo plugin al sistema. Por medio de `remove()` y `get()` podremos eliminar y modificar respectivamente plugins ya insertados. Pillars incluye por defecto varios plugins que realizan funciones fundamentales para el sistema, entre ellos el más importante es el plugin "Router".


					### Route

					Clase que permite asociar un controlador/manejador para una ruta y configuración concretas, un objeto Route consiste en una función manejador y una serie de propiedades que servirán para definir cuándo y cómo ejecutar dicho manejador, la forma más básica de crear un objeto Route es declarando sólo su manejador, dejando las opciones por defecto:

					```javascript
					var myRoute = new Route(function(gw){
					  gw.send('¡Hola Mundo!');
					});
					```

					Aunque en general necesitaremos configurar nuestro Route de la siguiente forma:

					```javascript
					var myRoute = new Route({ // Configuración
					  id:'Status',
					  path:'admin/status',
					  method:['get','post']
					},function(gw){ // Manejador
					  gw.html('¡Hola Mundo!');
					});
					```
					Route establece por defecto valores para las siguientes propiedades si no son especificadas:
					- .id: Por defecto se genera un identificador único para la ruta en caso de no especificar uno.
					- .path: Por defecto es '/'
					- .method: por defecto es 'GET'

					Los objetos Route a su vez pueden tener sub-rutas, de la misma forma que podemos añadir objetos Route al entorno, podemos añadirlos también como 'hijos' de otro objeto Route, estos funcionarán como subrutas, permitiéndonos organizar el árbol de rutas de forma más orgánica y como veremos más adelante nos servirá para trabajar con propiedades por herencia y tener un control organizado sobre grupos de controladores.

					```javascript
					var adminArea = new Route({
					  id: 'Administration',
					  path: '/admin'
					},function(gw){
					  gw.html('Admin area');
					});

					adminArea.routes.add(new Route({
					    id: 'Status',
					    path: '/status'
					  },function(gw){
					    gw.html('Admin area: Show status');
					}))
					```

					El objeto Route con el id 'Status' responderá a la ruta '/admin/status'. Si desactivamos al Route con el id 'Administration', dejarán de estar disponibles todos sus descendientes.

					También disponemos de la propiedad `.active` de Route, que por defecto es `true` y nos permite desactivar un Route junto con su correspondiente descendencia.

					### Gangway (gw)

					Es la solicitud HTTP, si ya has trabajado con Node.js estarás acostumbrado a los objetos `request` y `response`. En Pillars.js estos objetos son propiedades de Gangway, un objeto Gangway consiste en la solicitud del cliente completamente parseada y organizada para su uso. Con cada solicitud al servidor HTTP se crea un objeto Gangway que es recibido por el Route/manejador correspondiente. Algunas de las propiedades y métodos de Gangway:

					 - **`.cookie`**: Devuelve un objeto con el contenido de la *cookie*, si existiese.
					 - **`.ua`**: Un objeto con información sobre el agente de usuario, `.mobile` nos indica (*booleano*) si el cliente es un dispositivo móvil y el resto de propiedades nos aporta información sobre el sistema operativo y el navegador (os,engine,browser).
					 - **`.ip`**: La dirección IP del cliente.
					 - **`.accepts`**: Cabeceras accept ya resueltas y organizadas por prioridad.
					 - **`.host`**: El nombre de host o dirección IP que se ha utilizado al realizar la petición.
					 - **`.method`**: El método utilizado por la petición (*GET,POST,PUT,DELETE,HEAD*).
					 - **`.path`**: Ruta que se ha solicitado, exclusivamente el valor de la ruta sin la parte *host* ni *query*, este valor puede verse modificado internamente si por alguna razón una ruta es redirigida a otro punto del entorno, para conocer el *path* original tenemos la propiedad **`.originalPath`**.
					 - **`.query`**: Un objeto con el contenido del *query* de la petición.
					 - **`.params`**: Un objeto con todos los parámetros recibidos en la petición, ya sea por *GET* o *POST*. Los valores *POST* prevalecerán sobre los de *GET* en caso de ser idénticos.
					 - **`.files`**: Un objeto que contiene únicamente los archivos, si existiesen, que han sido enviados en la petición. En `.params` también podremos encontrar dichos archivos junto con el resto de parámetros que fueron enviados.
					 - **`.session`**: Un objeto que mantendrá sus propiedades entre distintas peticiones del mismo cliente.
					 - **`.referer`**: Si la solicitud se ha realizado por medio de un *link*, este valor nos indica la dirección que nos ha referenciado.

					> Puedes encontrar una descripción más amplia y el resto de propiedades
					> en la referencia.

					 - **`.setHeader(name, value)`**: Añade un encabezado a la respuesta. `getHeader(name)` y `removeHeader(name)`, nos permite leer un valor de encabezado ya existente o eliminarlo, como este se incluyen alias de los métodos propios de `response`.
					 - **`.setCookie(name, value, config)`**: Prepara una cookie para adjuntar a la respuesta, será encriptada por medio de JSON.crypt.
					 - **`.send(data)`**: Envía el contenido especificado al cliente y termina la petición, si *data* es un *objeto* se convertirá en *JSON* y la respuesta se enviará como *'aplication/json',* si data es un *string* será enviado como *'text/html'*. Existen, además, métodos explícitos para cada tipo de respuesta `.html()`, `.json`, `.text`.
					 - **`.file(path, clientname, download)`**: Envía un archivo al cliente, mediante `clientname` podremos especificar un nombre que será utilizado en el diálogo de guardado y con `download=true` podremos forzar la descarga del mismo. Por defecto el nombre es el que corresponda en la ruta y forzar descarga es *false*. Adicionalmente, el archivo será **comprimido** antes de su envío y quedará cacheado en memoria para sucesivas peticiones, este método es compatible la negociación **byte-serve** de HTTP por lo que si la descarga es interrumpida podrá continuar en una siguiente solicitud desde el último byte recibido, siendo también utilizado por clientes de video para descarga selectiva. Este método también tiene *gestión de caché automática*, por lo que si el cliente ya tiene el archivo no volverá a ser enviado y se responderá con un código *304*.
					 - **`.cacheck(hash)`**: Nos permite gestionar la caché del cliente, debemos pasar valor identificativo (hash, checksum, timestamp) para comprobar si el contenido solicitado es idéntico al que ya tiene el cliente, este método responderá con *false* si el cliente no tiene cacheado el contenido y *true* junto con un *304* automáticamente si el cliente ya dispone del contenido. La forma ideal de utilizar este método es como condición en una sentencia *if*, de la forma `if(!cacheck(hash)){}`.
					 - **`.authenticate(msg)`**: Envía un mensaje de *autenticación HTTP básica* con el código *401*. Podremos comprobar las credenciales del usuario en la propiedad `.auth` de Gangway, este objeto contendrá el nombre de usuario y contraseña indicados por el cliente en las propiedades `.user` y `.pass`.
					 - **`.redirect(location)`**: Redirige la solicitud a otra dirección mediante un código *301*.
					 - **`.render(template, locals)`**: Definiendo la ruta a un template y la variables de entorno con las que debe trabajar enviaremos al cliente el resultado como HTML. Pillars.js permite añadir motores de plantillas mediante `templated.addEngine(ext,compiler)`.
					 - **`.error(code, data)`**: Mediante este método podemos mostrar mensajes de *error* manualmente, nos permite especificar un *status-code (404, 500...)* y un objeto *Error* si fuese necesario, el objeto *Error* no se mostrará al cliente si la variable de entorno `debug` es *false*.

					## Plugin

					Los plugins te permiten crear controladores globales que podrán acceder a las propiedades de Route, ampliar las funciones de Gangway o modificar el comportamiento general del framework.

					Son la parte central de la gestión de solicitudes en Pillars.js. Cuando se recibe una solicitud HTTP se instancia un nuevo objeto Gangway, éste es enviado a una cadena de plugins organizados que irán pasando el control de dicho Gangway al siguiente Plugin.

					La construcción de un plugin es muy similar a la de un Route, es necesario especificar unas propiedades y un manejador. Los plugins solo tienen dos propiedades, `.id` y `.active`:

					```javascript
					myPlugin = new Plugin({
					  id: 'paramsLog'
					}, function(gw,next){
					  console.log(gw.params);
					  next();
					});
					project.plugins.add(myPlugin);
					```

					Este plugin de ejemplo envía a la consola los parámetros de cualquier solicitud recibida y pasa el control al siguiente plugin. Plugin a diferencia de Route recibe dos parámetros en el manejador 'gw' y 'next', next es un método que nos permite pasar el control al siguiente Plugin.

					Uno de los Plugins integrados, y más importante, es 'Router' que decide qué objeto Route es el encargado de atender una solicitud concreta, pasando el control al manejador de dicho Route cuando finaliza la cadena de Plugins.

					Cuando el control llega al Plugin 'Router', éste busca el Route adecuado para la solicitud, en caso de encontrar uno guarda la referencia en la propiedad `routing` de Gangway y continua la ejecución de la cadena de plugins. En caso contrario reponde con un 404 y detiene la cadena de Plugins.

					Desde cualquier Plugin con prioridad posterior a 'Router' se tendrá acceso a la propiedad `gw.routing` que tiene el siguiente formato:
					- `gw.routing.routes`: Cadena de Routes que se ha seguido si estos han sido anidados, en orden de descendencia.
					- `gw.routing.handlers`: Manejador o manejadores del Route que responderá a la ruta. Serán llamados al finalizar la cadena de Plugins.
					- `gw.routing.options`: Objeto con las propiedades del Route que atenderá la solicitud, propias y heredadas de otros Routes superiores.
					- `gw.routing.check(prop, preset)`: Utilidad para comprobar propiedades del Route pudiendo recibir el valor `preset` en caso de no estar definida.

					La propiedad `gw.routing` nos permite crear Plugins que sólo se ejecutarán ante configuraciones concretas Route, por ejemplo un Plugin que realize log como el ejemplo anterior pero sólo para objetos Route que tengan la propiedad 'log=true':

					```javascript
					myPlugin = new Plugin({
					  id: 'logPlugin'
					},function(gw,next){
					  var log = gw.routing.check('log');
					  if(log===true){
					    console.log(gw.path,gw.params);
					  }
					  next();
					});
					project.plugins.add(myPlugin);
					```

					Mediante Plugins podemos actuar tanto antes como después de pasar por el Router, pudiendo por ejemplo modificar la ruta o métodos antes del Router o comprobar propiedades del objeto Route cuando éste ya ha sido seleccionado. Cada Plugin puede modificar o extender las propiedades y métodos de Gangway para nuestro manejador, por ejemplo el Plugin 'sessions' nos ofrece la propiedad `gw.session` en la cual se encarga de insertar los valores almacenados en la sesión y guardar los cambios una vez finalizada la solicitud.

					Los Plugins ofrecen una forma de añadir funcionalidades a Pillars.js o modificar su comportamiento general, esto es útil para crear Plugins genéricos que añadan funciones a cualquier proyecto o para realizar tareas comunes entre diferentes manejadores pudiendo disparar el Plugin sólo ante ciertas propiedades/configuraciones de Route.*/
