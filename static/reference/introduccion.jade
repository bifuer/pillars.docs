include ../.layout.jade

doctype html
html(lang=gw.language)
	- var path = [{label:'Pillars.js Reference',url:'/pillars/docs/reference/'},{label:'Introducción',url:'/pillars/docs/reference/introduccion.jade'}];
	+reference-layout("Pillars.js Reference - Introducción - 'make it easy!'",path)

		#title
			h1 Introducción
				em  Pillars.js Reference
			

		//- Summary
		section.summary
			:markdown
				Pillars.js proporciona un entorno de trabajo con herramientas para el desarrollo de aplicaciones web en Node.js. 
				
				En Pillars.js hay cinco conceptos básicos:
				+ **El entorno** o **proyecto**, es la variable que devuelve la librería `var proyect = require('pillars');`. Nos ofrece un entorno inicial y herramientas para la construcción de la aplicación web.
				+ **Servicios**, conjunto de servicios disponibles y ampliables en el entorno, tales como http, https, MongoDB o MySQL. Un proyecto Pillars.js permite varios servicios del mismo tipo, por ejemplo varios servicios http.
				+ **Routes**. El soporte a este elemento lo realiza la **Clase Route**, mediante objetos route se definen rutas que atenderá la aplicación. Ofrecen la versatilidad de anidamiento y son conectables y desconectables "en caliente".
				+ **Gangway**. Se genera un objeto gangway automáticamente en cada petición, contiene el request y el response de Node.js. La potencia de gangway son sus datos del request parseados y listos para su uso así como métodos para la respuesta como `gw.file()` que permite enviar archivos al cliente compatible con el protocolo por partes de http, entre muchos otros.
				+ **Plugins**. La **Clase Plugin** permite ampliar las funcionalidades del framework.

				
				-----------------------------------
				Funcionamiento

				El funcionamiento y el flujo de trabajo de Pillars.js se basa en la **Cadena de Plugins**. 

				La Cadena de Plugins es una variable de tipo ObjectArray, es decir, un Array de Objetos con métodos para añadir, mover y eliminar objetos en el Array. Así, se conforma una lista ordenada de Plugins que se ejecutan de manera secuencial por cada petición de usuario.

				[Dibujo-------------------------------]

				Pillars.js incorpora una serie de [Plugins nativos]. El más importante de todos ellos es el **plugin Router**, que es el encargado de enroutar la petición del usuario, haciendo por lo tanto que dada una petición ésta la ejecute el *handler* del objeto route pertinente.

				Dicho de otra forma, todas las rutas que atiende el proyecto web, se construyen mediante objetos route. Todos estos objetos route están contenidos en la **Cadena de Routes**, que es de tipo ObjectArray, dando de esta forma la versatilidad de añadir o eliminar rutas de la aplicación incluso en funcionamiento.

				En Pillars.js hay dos objetos que no forman parte en sí mismos de las herramientas de desarrollo, pero que dotan de funcionalidades excepcionales al framework, estos objetos son: 
				+ La Cadena de Routes. La cadena de routes es una variable de tipo ObjectArray que contiene objetos de tipo Route.
				+ La Cadena de Plugins. La cadena de plugins es una variable de tipo ObjectArray que contiene objetos de tipo Plugin. 
				


	
		//- Properties
		section.description
			h2#description Descripción
			:markdown
				El **flujo** que sigue Pillars.js, así como su interacción con Node.js, es la siguiente: 

				**1**. Cuando el cliente realiza una petición se dispara el evento “request” de Node.js. Pillars.js [captura este evento](https://github.com/bifuer/pillars/blob/master/lib/ENV.js#L145), que contiene el request y el response, parsea los datos contenidos en request y los setea de forma ordenada y accesible en el **objeto Gangway**. Por lo tanto, por cada petición de cliente, se creará un objeto gangway.

				> [Ver los parses que realiza el objeto gangway](/pillars/docs/reference/gangway.jade#description) de los datos del request.

				**2**. Una vez que gangway realiza todo el parseo y setea todas las propiedades, Pillars.js emite el [evento gangway](https://github.com/bifuer/pillars/blob/master/lib/ENV.js#L147). Este evento es [capturado](https://github.com/bifuer/pillars/blob/master/lib/ENV.js#L506) y seguidamente se ejecuta la **Cadena de Plugins**.

				---


			//- Property
			section.description
				h3#description-plugins Cadena de Plugins

				//- Property description
				section.description
					:markdown
						 En Pillars.js tenemos un listado de objetos tipo plugin que se van ejecutando en orden y de forma concatenada. Este listado es el llamado Cadena de Plugins. 

						 Los objetos plugin se crean con la clase Plugin del mismo framework. 

						 El orden de ejecución de los objetos plugin es importante, está determinado en la Cadena de Plugins en función a su orden de adicción y es modificable. 

						El sistema que se ha utilizado para encadenar objetos y que éstos se ejecuten en orden y de forma asíncrona está implementado en el framework y es el [Sistema de Nexting](https://github.com/bifuer/pillars/blob/master/lib/ENV.js#L514).

						Los Plugins que conforman la **Cadena de Plugins nativa de Pillars.js** son por ejemplo: 

						+ [Plugin de Sesiones](/pillars/docs/reference/plugins.jade#plugin-sessions)
						+ [Plugin de enrutado](/pillars/docs/reference/plugins.jade#plugin-router)
						+ [Plugin de Sistema de Usuarios](/pillars/docs/reference/plugins.jade#plugin-accounts)

						Uno de los más interesantes es el **plugin router.js**, que es el encargado de realizar el **sistema de enrutado de Pillars.js**. Tiene prioridad 100. 

						> [Ver los plugins nativos en Pillars.js](/pillars/docs/reference/plugins.jade).

						---


			//- Property
			section.description
				h3#description-router Sistema de enrutado

				//- Property description
				section.description
					:markdown
						El sistema de enrutado en Pillars está implementado de forma modular y anidable. 

						Los diferentes controladores, que actuarán en una ruta determinada y con unas características específicas, se declaran mediante objetos de la Clase Route, por lo tanto los objetos route conformarán la arquitectura de nuestra aplicación web. 

						Estos objetos route son **anidables**,  “**conectables**” y “**desconectables**” en caliente a nuestra aplicación. De forma que podemos tener varios objetos route que implementan una serie de funcionalidades agrupados formando una estructura de árbol, de forma que desconectando al “route raíz” de la aplicación web, hacemos que esa serie de funcionalidades dejen de estar disponibles en nuestra aplicación. Al igual, es posible **conectar objetos route** en caliente, haciendo que estén disponibles las funcionalidades que éstos implementen.

						---

				
			:markdown
				**3**. En la **Cadena de Plugins** existen Plugins de menor y mayor importancia. El más destacable es el **plugin router.js**, que lee todos los objetos “route raíz” que están “conectados” a la aplicación, y comprueba si los parámetros de configuración del route coinciden con los parámetros de la petición, y por lo tanto si debe ejecutar el handler de ese objeto route, seguir recorriendo el árbol, o pasar a otro “route raíz”. 

				Una vez que se encuentra el objeto route que coincide con la petición de usuario, se guarda el handler en gw.routing, y sigue la ejecución de la cadena de plugins hasta la finalización.


				**4**. Una vez finalice toda la cadena de Plugins, se ejecuta el handler del objeto route que coincidió con la petición de usuario. Este handler es el que realiza el response al cliente.

				---


			//- Property
			section.description
				h3#description-addrouter Conexión y Desconexión de objetos a la aplicación

				//- Property description
				section.description
					:markdown
						Los objetos plugins y route los conectamos a la aplicación mediante ENV, que es el punto de anclaje y de configuración de la aplicación web. 

					:highlight(lang='javascript')
						var route = new Route(function(gw){
							gw.send(“Hola Mundo”);
						});
						ENV.addRoute( route );

					:markdown
						En los ejemplos verás que utilizamos addRoute() en vez de ENV.addRoute(), ya que la mayoría de métodos de ENV más utilizados están **seteados de forma global**. 

						> Puedes consultar todas las [variables seteadas de forma global aquí](/pillars/docs/reference/entorno.jade#vblesglobales).

						En ENV (entorno de la aplicación) se configura el comportamiento de nuestra aplicación: puerto al que responderá, servidor smtp, etc. 

						> Consulta [todas las propiedades de ENV aquí](/pillars/docs/reference/entorno.jade#properties).

						---

			//- Property
			section.description
				h3#description-pluginschain Ventajas de la Cadena de Plugins

				//- Property description
				section.description
					:markdown
						Esta filosofía permite la posibilidad de añadir funcionalidades al framework mediante Plugins, permitiendo especificar el orden de ejecución del mismo en la cadena de plugins; antes o después del plugin router, o de cualquier otro plugin.

						Es por ello que en la creación de plugins hay que tener muy encuenta los plugins añadidos al entorno y su prioridad de ejecución. Esta información la tenemos disponible en ENV.plugins.

						---


			//- Property
			section.description
				h3#description-pluginschain Ventajas de enrutado mediante objetos

				//- Property description
				section.description
					:markdown
						Un objeto route, que será un controlador, está compuesto por: 


					:highlight(lang='javascript')
						var route = new Route( configuration, handler );


					:markdown
						La configuración contendrá propiedades que activarán unos plugins u otros. Obviamente los plugins que dependan en alguna medida de la configuración del route, deberán estar añadidos después de éste. 

						Por otro lado, al ser objetos tenemos la posibilidad de conectar y desconectar dinámicamente de la aplicación, reordenarlos y crear librerías que monten en una determinada ruta, ciertas funcionalidades.

						Al ser objetos anidables, Pillars.js ahorra también tiempo de proceso, al buscar en primera instancia el objeto route que casa con la petición de usuario, sólo en los route raíz. Una vez que uno de ellos coincida parcialmente, sigue profundizando en el árbol. Esta búsqueda es sobradamente más eficiente que una búsqueda lineal en controladores escritos en un determinado orden en el código.


					:highlight(lang='javascript')
						var routeInscripcion = new Route({id:”inscripcion”, path:”/inscripcion”}, function(gw){
						// Muestra formulario de inscripción	
						})

						var routeListado = new Route({id:”listado”, path: “/listado”}, function(gw){
						// Muestra un listado con las inscripciones realizadas
						});

						//Agregamos routeListado como hijo de routeInscripcion
						routeInscripcion.addRoute(routeListado);

						//Agregamos a la aplicación el route “inscripcion”
						addRoute(routeInscripcion);

					:markdown
						---